"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
exports.__esModule = true;
/* tslint:disable no-console */
require("isomorphic-fetch");
var settings_1 = require("./settings");
var types_1 = require("../../types");
var requestError = function (statusText) { return Promise.reject("Request error: " + statusText); };
/**
 * Sends an http request to a specified host.
 *
 * @method send
 *
 * @memberof module:http-client
 *
 * @param {Command} command
 *
 * @param {String} [uri=http://localhost:14265]
 *
 * @param {String|Number} [apiVersion=1]
 *
 * @return Promise
 * @fulil {Object} - Response
 * @reject {Error} - Request error
 */
exports.send = function (command, uri, apiVersion) {
    if (uri === void 0) { uri = settings_1.DEFAULT_URI; }
    if (apiVersion === void 0) { apiVersion = settings_1.API_VERSION; }
    return fetch(uri, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-IOTA-API-Version': apiVersion.toString()
        },
        body: JSON.stringify(command)
    })
        .then(function (res) { return (res.ok ? res.json() : requestError(res.statusText)); })
        .then(function (json) { return (json.error || json.exception ? requestError(json.error || json.exception) : json); });
};
/**
 * Sends a batched http request to a specified host
 * supports findTransactions, getBalances & getTrytes commands
 *
 * @method batchedSend
 *
 * @param {Command} command
 *
 * @param {String[]} keysToBatch
 *
 * @param {Number} [requestBatchSize=1000]
 *
 * @param {String} [uri='http://localhost:14265']
 *
 * @param {String|Number} [apiVersion=1]
 *
 * @ignore
 *
 * @return Promise
 * @fulil {Object} - Response
 * @reject {Error} - Request error
 */
exports.batchedSend = function (command, keysToBatch, requestBatchSize, uri, apiVersion) {
    if (requestBatchSize === void 0) { requestBatchSize = settings_1.MAX_REQUEST_BATCH_SIZE; }
    if (uri === void 0) { uri = settings_1.DEFAULT_URI; }
    if (apiVersion === void 0) { apiVersion = settings_1.API_VERSION; }
    return Promise.all(keysToBatch.map(function (key) {
        return Promise.all(command[key]
            .reduce(function (acc, _, i) {
            return i < Math.ceil(command[key].length / requestBatchSize)
                ? acc.concat((_a = {
                        command: command.command
                    },
                    _a[key] = command[key].slice(i * requestBatchSize, (1 + i) * requestBatchSize),
                    _a))
                : acc;
            var _a;
        }, [])
            .map(function (batchedCommand) { return exports.send(batchedCommand, uri, apiVersion); })).then(function (res) { return res.reduce(function (acc, batch) { return acc.concat(batch); }, []); });
    })).then(function (responses) {
        switch (command.command) {
            case types_1.IRICommand.FIND_TRANSACTIONS:
                return {
                    hashes: responses[0][0].hashes.filter(function (hash) {
                        return responses.every(function (_response) {
                            return _response.findIndex(function (res) { return res.hashes.indexOf(hash) > -1; }) > -1;
                        });
                    })
                };
            case types_1.IRICommand.GET_BALANCES:
                return __assign({}, responses[0]
                    .slice()
                    .sort(function (a, b) { return a.milestoneIndex - b.milestoneIndex; })
                    .slice(-1), { balances: responses[0].reduce(function (acc, response) { return acc.concat(response.balances); }, []) });
            case types_1.IRICommand.GET_INCLUSION_STATES:
                return __assign({}, responses[0][0], { states: responses[0].reduce(function (acc, response) { return acc.conact(response.states); }) });
            default:
                requestError('Invalid batched request.');
        }
    });
};
//# sourceMappingURL=request.js.map