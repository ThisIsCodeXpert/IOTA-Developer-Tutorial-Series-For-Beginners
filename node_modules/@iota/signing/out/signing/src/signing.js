"use strict";
/** @module signing */
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var pad_1 = require("@iota/pad");
var add_1 = require("./add");
var errors = require("./errors");
/**
 * @method subseed
 *
 * @param {Int8Array} seed - Seed trits
 * @param {number} index - Private key index
 *
 * @return {Int8Array} subseed trits
 */
function subseed(seed, index) {
    if (index < 0) {
        throw new Error(errors.ILLEGAL_KEY_INDEX);
    }
    if (seed.length % 3 !== 0) {
        throw new Error(errors.ILLEGAL_SEED_LENGTH);
    }
    var indexTrits = converter_1.fromValue(index);
    var subseed = add_1["default"](seed, indexTrits);
    while (subseed.length % 243 !== 0) {
        subseed = pad_1.padTrits(subseed.length + 3)(subseed);
    }
    var kerl = new kerl_1["default"]();
    kerl.initialize();
    kerl.absorb(subseed, 0, subseed.length);
    kerl.squeeze(subseed, 0, subseed.length);
    return subseed;
}
exports.subseed = subseed;
/**
 * @method key
 *
 * @param {Int8Array} subseed - Subseed trits
 * @param {number} length - Private key length
 *
 * @return {Int8Array} Private key trits
 */
function key(subseed, length) {
    if (subseed.length % 3 !== 0) {
        throw new Error(errors.ILLEGAL_SUBSEED_LENGTH);
    }
    var kerl = new kerl_1["default"]();
    kerl.initialize();
    kerl.absorb(subseed, 0, subseed.length);
    var buffer = new Int8Array(kerl_1["default"].HASH_LENGTH);
    var result = new Int8Array(length * 27 * 243);
    var offset = 0;
    while (length-- > 0) {
        for (var i = 0; i < 27; i++) {
            kerl.squeeze(buffer, 0, subseed.length);
            for (var j = 0; j < 243; j++) {
                result[offset++] = buffer[j];
            }
        }
    }
    return result;
}
exports.key = key;
/**
 * @method digests
 *
 * @param {Int8Array} key - Private key trits
 *
 * @return {Int8Array}
 */
// tslint:disable-next-line no-shadowed-variable
function digests(key) {
    var l = Math.floor(key.length / 6561);
    var result = new Int8Array(l * 243);
    var buffer = new Int8Array(kerl_1["default"].HASH_LENGTH);
    for (var i = 0; i < l; i++) {
        var keyFragment = key.slice(i * 6561, (i + 1) * 6561);
        for (var j = 0; j < 27; j++) {
            buffer = keyFragment.slice(j * 243, (j + 1) * 243);
            for (var k = 0; k < 26; k++) {
                var keyFragmentKerl = new kerl_1["default"]();
                keyFragmentKerl.initialize();
                keyFragmentKerl.absorb(buffer, 0, buffer.length);
                keyFragmentKerl.squeeze(buffer, 0, kerl_1["default"].HASH_LENGTH);
            }
            for (var k = 0; k < 243; k++) {
                keyFragment[j * 243 + k] = buffer[k];
            }
        }
        var digestsKerl = new kerl_1["default"]();
        digestsKerl.initialize();
        digestsKerl.absorb(keyFragment, 0, keyFragment.length);
        digestsKerl.squeeze(buffer, 0, kerl_1["default"].HASH_LENGTH);
        for (var j = 0; j < 243; j++) {
            result[i * 243 + j] = buffer[j];
        }
    }
    return result;
}
exports.digests = digests;
/**
 * @method address
 *
 * @param {Int8Array} digests - Digests trits
 *
 * @return {Int8Array} Address trits
 */
// tslint:disable-next-line no-shadowed-variable
function address(digests) {
    var addressTrits = new Int8Array(kerl_1["default"].HASH_LENGTH);
    var kerl = new kerl_1["default"]();
    kerl.initialize();
    kerl.absorb(digests.slice(), 0, digests.length);
    kerl.squeeze(addressTrits, 0, kerl_1["default"].HASH_LENGTH);
    return addressTrits;
}
exports.address = address;
/**
 * @method digest
 *
 * @param {array} normalizedBundleFragment - Normalized bundle fragment
 * @param {Int8Array} signatureFragment - Signature fragment trits
 *
 * @return {Int8Array} Digest trits
 */
// tslint:disable-next-line no-shadowed-variable
function digest(normalizedBundleFragment, signatureFragment) {
    var digestKerl = new kerl_1["default"]();
    digestKerl.initialize();
    var buffer = new Int8Array(kerl_1["default"].HASH_LENGTH);
    for (var i = 0; i < 27; i++) {
        buffer = signatureFragment.slice(i * 243, (i + 1) * 243);
        for (var j = normalizedBundleFragment[i] + 13; j-- > 0;) {
            var signatureFragmentKerl = new kerl_1["default"]();
            signatureFragmentKerl.initialize();
            signatureFragmentKerl.absorb(buffer, 0, kerl_1["default"].HASH_LENGTH);
            signatureFragmentKerl.squeeze(buffer, 0, kerl_1["default"].HASH_LENGTH);
        }
        digestKerl.absorb(buffer, 0, kerl_1["default"].HASH_LENGTH);
    }
    digestKerl.squeeze(buffer, 0, kerl_1["default"].HASH_LENGTH);
    return buffer;
}
exports.digest = digest;
/**
 * @method signatureFragment
 *
 * @param {array} normalizeBundleFragment - normalized bundle fragment
 * @param {keyFragment} keyFragment - key fragment trits
 *
 * @return {Int8Array} Signature Fragment trits
 */
function signatureFragment(normalizedBundleFragment, keyFragment) {
    var sigFragment = keyFragment.slice();
    var kerl = new kerl_1["default"]();
    for (var i = 0; i < 27; i++) {
        var hash = sigFragment.slice(i * 243, (i + 1) * 243);
        for (var j = 0; j < 13 - normalizedBundleFragment[i]; j++) {
            kerl.initialize();
            kerl.reset();
            kerl.absorb(hash, 0, kerl_1["default"].HASH_LENGTH);
            kerl.squeeze(hash, 0, kerl_1["default"].HASH_LENGTH);
        }
        for (var j = 0; j < 243; j++) {
            sigFragment[i * 243 + j] = hash[j];
        }
    }
    return sigFragment;
}
exports.signatureFragment = signatureFragment;
/**
 * @method validateSignatures
 *
 * @param {string} expectedAddress - Expected address trytes
 * @param {array} signatureFragments - Array of signatureFragments trytes
 * @param {string} bundleHash - Bundle hash trytes
 *
 * @return {boolean}
 */
function validateSignatures(expectedAddress, signatureFragments, bundleHash) {
    if (!bundleHash) {
        throw new Error(errors.INVALID_BUNDLE_HASH);
    }
    var normalizedBundleFragments = [];
    var normalizedBundle = exports.normalizedBundleHash(bundleHash);
    // Split hash into 3 fragments
    for (var i = 0; i < 3; i++) {
        normalizedBundleFragments[i] = normalizedBundle.slice(i * 27, (i + 1) * 27);
    }
    // Get digests
    // tslint:disable-next-line no-shadowed-variable
    var digests = new Int8Array(signatureFragments.length * 243);
    for (var i = 0; i < signatureFragments.length; i++) {
        var digestBuffer = digest(normalizedBundleFragments[i % 3], converter_1.trits(signatureFragments[i]));
        for (var j = 0; j < 243; j++) {
            digests[i * 243 + j] = digestBuffer[j];
        }
    }
    return expectedAddress === converter_1.trytes(address(digests));
}
exports.validateSignatures = validateSignatures;
/**
 * Normalizes the bundle hash, with resulting digits summing to zero.
 *
 * @method normalizedBundleHash
 *
 * @param {Hash} bundlehash - Bundle hash trytes
 *
 * @return {Int8Array} Normalized bundle hash
 */
exports.normalizedBundleHash = function (bundleHash) {
    var normalizedBundle = new Int8Array(81);
    for (var i = 0; i < 3; i++) {
        var sum = 0;
        for (var j = 0; j < 27; j++) {
            sum += normalizedBundle[i * 27 + j] = converter_1.value(converter_1.trits(bundleHash.charAt(i * 27 + j)));
        }
        if (sum >= 0) {
            while (sum-- > 0) {
                for (var j = 0; j < 27; j++) {
                    if (normalizedBundle[i * 27 + j] > -13) {
                        normalizedBundle[i * 27 + j]--;
                        break;
                    }
                }
            }
        }
        else {
            while (sum++ < 0) {
                for (var j = 0; j < 27; j++) {
                    if (normalizedBundle[i * 27 + j] < 13) {
                        normalizedBundle[i * 27 + j]++;
                        break;
                    }
                }
            }
        }
    }
    return normalizedBundle;
};
//# sourceMappingURL=signing.js.map